"""Functions for generating the stop removal reports."""
import csv
from datetime import datetime
from typing import List, Tuple, Dict

from msnmetrosim.views.controllers import ctrl_population, ctrl_stops_cross
from .static import IMPACT_REPORT_HEADER


# region Report generating


def generate_stop_removal_report(range_km: float, interval_km: float, /,
                                 report_path: str = "stop-rm-report.csv", use_population_data: bool = True):
    """
    Generate a stop removal report in csv and output it to ``report_path``.

    Both ``range_km`` and ``interval_km`` will be used for agent spawning.

    The header of the generated report contains:

    - `cross_hash`: Hash code of the cross
    - `rank`: Rank of the impact index, sorted from the largest
    - `cross_1`: Name of the cross #1
    - `cross_2`: Name of the cross #2
    - `impact_index`: Impact index
    - `generated_time`: Report generation time
    - `agent_range`: Range in km used for agent spawning
    - `agent_interval`: Interval in km used for agent spawning
    """
    # Get a list of results of removing each stops
    results = ctrl_stops_cross.get_all_stop_remove_results(range_km, interval_km,
                                                           ctrl_population if use_population_data else None)

    # Generate the report to `report_path`
    with open(report_path, "w", newline="") as f:
        writer = csv.writer(f)
        now = datetime.now()

        # Write header
        writer.writerow(IMPACT_REPORT_HEADER)

        # Write each data
        for rank, result in enumerate(sorted(results, key=lambda r: r.impact_index, reverse=True), start=1):
            writer.writerow(
                [
                    rank,
                    result.stop_removed.primary,
                    result.stop_removed.secondary,
                    result.impact_index,
                    now,
                    range_km,
                    interval_km
                ]
            )


# endregion


# region Report Matching


def load_report_rank(report_path: str) -> Dict[Tuple[str, str], int]:
    """Load the ranks in the report to a :class:`dict` where streets as the key; rank as the value."""
    report_rank: Dict[Tuple[str, str], int] = {}

    # Prepare report 2 rank lookup table
    with open(report_path, "r", newline="") as f:
        reader = csv.reader(f)

        next(reader)  # skip the header

        for line in reader:
            rank = int(line[IMPACT_REPORT_HEADER.index("rank")])
            street_comb = (line[IMPACT_REPORT_HEADER.index("cross_1")], line[IMPACT_REPORT_HEADER.index("cross_2")])

            report_rank[street_comb] = rank

    return report_rank


def get_report_rank_change(report_1_path: str, report_2_path: str, /,
                           count: int = None, reverse: bool = False) \
        -> List[Tuple[Tuple[str, str], int, int]]:
    """
    Get the rank change between ``report_1_path`` and ``report_2_path``.

    Both of the ``report_1_path`` and ``report_2_path``
    must be the impact index report generated by calling ``generate_stop_removal_report()``.

    The return will be sorted by the rank of the 1st report.
    Set ``reverse`` to ``True`` gives the last data first.

    - Note that reversedly getting the data will load all report into the memory
      whereas loading the data in its order will not.

    If ``count`` is not ``None``, only ``count`` data will be returned.

    Each element of the return contains the sub-elements as listed in the order below:

    - Street combination in tuple

    - Rank in the 1st report

    - Rank in the 2nd report

    .. note::
        This assumes that the data of 1st report is sorted by rank.
    """
    report_2_rank = load_report_rank(report_2_path)

    ret: List[Tuple[Tuple[str, str], int, int]] = []

    # Match the rank in the 1st report and the 2nd one
    with open(report_1_path, "r", newline="") as f:
        reader = csv.reader(f)

        next(reader)  # skip the header

        if reverse:
            reader = reversed(list(reader))

        for line, _ in zip(reader, range(count)):
            rank = int(line[IMPACT_REPORT_HEADER.index("rank")])
            street_comb = (line[IMPACT_REPORT_HEADER.index("cross_1")], line[IMPACT_REPORT_HEADER.index("cross_2")])

            ret.append((street_comb, rank, report_2_rank[street_comb]))

    return ret


def print_report_rank_change(report_1_path: str, report_2_path: str, /,
                             count: int = None, reverse: bool = False):
    """
    Same functionality as ``get_report_rank_change()`` with slightly formatted output printed to the console.

    If ``count`` is not ``None``, only ``count`` data will be printed.

    Header of the output will **NOT** be printed.

    The header is as below:

    - Street combinations name

    - Rank in report 1

    - Rank in report 2

    - Rank difference
    """
    changes = get_report_rank_change(report_1_path, report_2_path, count=count, reverse=reverse)

    for change in changes:
        street_comb_name = " & ".join(change[0])
        report_1_rank = change[1]
        report_2_rank = change[2]
        report_rank_diff = report_1_rank - report_2_rank

        print(f"\"{street_comb_name}\",{report_1_rank},{report_2_rank},{report_rank_diff}")

# endregion
